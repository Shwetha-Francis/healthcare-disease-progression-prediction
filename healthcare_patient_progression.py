# -*- coding: utf-8 -*-
"""Healthcare:patient_progression.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CPy8nR9kKnLF76bcOLLbs6zMhy973uIz
"""

# ------------------------------------------------------------------------
# Project: Healthcare - Predicting Patient Disease Progression
# ------------------------------------------------------------------------
# This project focuses on predicting the progression of a disease in patients
# using clinical, lifestyle, and biomarker data. The goal is to classify
# patients into different disease stages (e.g., Stage 0, 1, 2) based on
# their health indicators and to anticipate potential worsening or improvement.

#Import Libraries

import pandas as pd
import numpy as np

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, LabelEncoder

from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier
from sklearn.neighbors import KNeighborsClassifier

from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

import matplotlib.pyplot as plt
import seaborn as sns

#Load Dataset

df = pd.read_csv("chronic_disease_progression.csv")
df.head()

#EDA

print("\nDataset Info:")
print(df.info())# Check basic information

print("\nStatistical Summary:")
print(df.describe())# View summary statistics for numerical features

print("\nMissing Values:")
print(df.isnull().sum())# Check for missing values in each column

print("\nTarget Class Distribution:")
print(df['Stage'].value_counts())# Check class balance of target variable (important for classification)

sns.countplot(x='Stage', data=df)
plt.title("Target Class Distribution")#Visualize the target distribution
plt.show()

#Data Preprocessing

#Handle missing values properly

numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns #numeric columns
# Separate numeric
categorical_cols = df.select_dtypes(include=['object']).columns #categorical columns

df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].mean())# Fill numeric NaN with mean

df[categorical_cols] = df[categorical_cols].fillna(df[categorical_cols].mode().iloc[0])# Fill categorical NaN with mode

#Encode ALL categorical variables
le = LabelEncoder()
for col in categorical_cols:
    df[col] = le.fit_transform(df[col])

# Separate features (X) and target (y)

X = df.drop('Stage', axis=1)  # Features
y = df['Stage']               # Target

X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
) #Split dataset into train and test (80/20)

#Feature scaling
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Model Training and Evaluation

# Function to train, predict and evaluate model
def evaluate_model(model, X_train, X_test, y_train, y_test):
    model.fit(X_train, y_train)              # Train the model
    y_pred = model.predict(X_test)           # Predict on test set

    acc = accuracy_score(y_test, y_pred)     # Accuracy
    cm = confusion_matrix(y_test, y_pred)    # Confusion matrix
    report = classification_report(y_test, y_pred)  # Precision, Recall, F1-score

    print(f"Model: {model.__class__.__name__}")
    print(f"Accuracy: {acc:.4f}")
    print("Confusion Matrix:\n", cm)
    print("Classification Report:\n", report)

    # Plot confusion matrix
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(f"{model.__class__.__name__} Confusion Matrix")
    plt.ylabel('Actual')
    plt.xlabel('Predicted')
    plt.show()

    return acc

#Logistic Regression

log_reg = LogisticRegression(random_state=42)
acc_lr = evaluate_model(log_reg, X_train, X_test, y_train, y_test)

from sklearn.svm import SVC
# Support Vector Machine (SVM)

svm_model = SVC(kernel='rbf', random_state=42)
acc_svm = evaluate_model(svm_model, X_train, X_test, y_train, y_test)

from sklearn.neural_network import MLPClassifier

# Multi-Layer Perceptron (Neural Network)

mlp_model = MLPClassifier(hidden_layer_sizes=(64, 32),
                          activation='relu',
                          solver='adam',
                          max_iter=300,
                          random_state=42)
acc_mlp = evaluate_model(mlp_model, X_train, X_test, y_train, y_test)

# Compare Models

models = ['Logistic Regression', 'SVM', 'MLP']
accuracy = [acc_lr, acc_svm, acc_mlp]

plt.figure(figsize=(8,5))
sns.barplot(x=models, y=accuracy)
plt.title("Model Comparison - Accuracy")
plt.ylabel("Accuracy")
plt.ylim(0,1)
plt.show()

# Predict stages for all patients (scaled features)

# Select only feature columns (exclude Stage and Predicted_Stage)
feature_cols = [col for col in df.columns if col not in ['Stage', 'Predicted_Stage']]

X_all_scaled = scaler.transform(df[feature_cols])#Scaled stages

df['Predicted_Stage'] = mlp_model.predict(X_all_scaled)# Predict stages

# Create progression DataFrame

progression_df = df[['PatientID', 'Stage', 'Predicted_Stage']].copy()

# Create a new column showing progression
def progression(row):
    if row['Predicted_Stage'] > row['Stage']:
        return "Worse"
    elif row['Predicted_Stage'] < row['Stage']:
        return "Improved"
    else:
        return "Same"

progression_df['Progression'] = progression_df.apply(progression, axis=1)

progression_df.head(20)# Show first 20 patients

# Heatmap for Current Stage

current_stage_counts = df['Stage'].value_counts().sort_index()
plt.figure(figsize=(6,4))
sns.heatmap(current_stage_counts.values.reshape(-1,1),
            annot=True, fmt='d', cmap='YlOrRd', cbar=True,
            yticklabels=[f'Stage {i}' for i in current_stage_counts.index],
            xticklabels=['Count'])
plt.title("Distribution of Current Stage")
plt.show()

# Heatmap for Predicted Stage

predicted_stage_counts = df['Predicted_Stage'].value_counts().sort_index()
plt.figure(figsize=(6,4))
sns.heatmap(predicted_stage_counts.values.reshape(-1,1),
            annot=True, fmt='d', cmap='YlGnBu', cbar=True,
            yticklabels=[f'Stage {i}' for i in predicted_stage_counts.index],
            xticklabels=['Count'])
plt.title("Distribution of Predicted Stage")
plt.show()

# ------------------------------------------------------------------------
# Conclusion:
# ------------------------------------------------------------------------
# In this project, we predicted patient disease progression using clinical,
# lifestyle, and biomarker data. The MLP (Multi-Layer Perceptron) model
# was selected as the best-performing model for predicting the next stage of disease.
#
# Heatmaps were used to visualize both the current and predicted stages of patients,
# making it easy to identify trends, such as patients at risk of progression or
# those likely to remain stable.
#
# This demonstrates how machine learning and visual analytics can assist healthcare
# providers in monitoring patient outcomes and planning early interventions effectively.
# ------------------------------------------------------------------------